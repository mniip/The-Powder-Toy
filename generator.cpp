#include <string>
#include <iostream>
#include <sstream>
#include <iterator>
#include <fstream>
#include <algorithm>
#include <list>
#include <vector>
#include <numeric>
#include <map>
#include <dirent.h>

template<class InputIterator> std::string flatten(InputIterator first, InputIterator last)
{
	std::string accumulator;
	for(InputIterator iter = first; iter != last; iter++)
		if(iter == first)
			accumulator = *iter;
		else
			accumulator += " " + *iter;
	return accumulator;
}

bool sort_elements(std::vector<std::string> a, std::vector<std::string> b)
{
	std::istringstream as(a[3]);
	std::istringstream bs(b[3]);
	int an = 0, bn = 0;
	as >> an;
	bs >> bn;
	return an < bn;
}

void generate_elements(std::list<std::string> files)
{
	std::stringstream cpp, h;
	h <<
		"// This file is automatically generated by " __FILE__ "\n"
		"#ifndef ELEMENTCLASSES_H\n"
		"#define ELEMENTCLASSES_H\n"
		"#include <vector>\n"
		"#include \"simulation/Element.h\"\n"
		"#include \"simulation/elements/Element.h\"\n"
		"\n";
	cpp <<
		"// This file is automatically generated by " __FILE__ "\n"
		"#include \"ElementClasses.h\"\n"
		"std::vector<Element> GetElements()\n"
		"{\n"
		"\tstd::vector<Element> elements;\n";
	std::list<std::vector<std::string> > directives;
	for(std::list<std::string>::const_iterator iter = files.begin(), end = files.end(); iter != end; iter++)
	{
		std::ifstream file;
		file.open(iter->c_str());
		if(!file.good())
		{
			file.open(("src/simulation/elements/" + *iter).c_str());
			if(!file.good())
			{
				std::cout << "Could not open " << *iter << std::endl;
				continue;
			}
		}
		while(!file.eof())
		{
			std::string line;
			std::getline(file, line);
			if(!line.compare(0, 17, "//#TPT-Directive "))
			{
				std::istringstream iss(line.substr(17));
				std::vector<std::string> tokens;
				std::copy(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>(), std::back_inserter<std::vector<std::string> >(tokens));
				directives.push_back(tokens);
			}
		}
	}
	std::vector<std::vector<std::string> > element_ids;
	std::map<std::string,std::string> element_classes;
	for(std::list<std::vector<std::string> >::const_iterator iter = directives.begin(), end = directives.end(); iter != end; iter++)
	{
		if(!(*iter)[0].compare("ElementClass"))
			element_ids.push_back(*iter);
		else if(!(*iter)[0].compare("ElementHeader"))
		{
			std::string class_name = (*iter)[1];
			ssize_t pos = class_name.find(':');
			if(pos != std::string::npos)
				class_name = class_name.substr(0, pos);
			element_classes[class_name] += flatten((*iter).begin()+2, (*iter).end()) + ";";
		}
	}
	std::sort(element_ids.begin(), element_ids.end(), sort_elements);
	for(std::vector<std::vector<std::string> >::const_iterator iter = element_ids.begin(), end = element_ids.end(); iter != end; iter++)
	{
		std::string class_name = (*iter)[1];
		std::string class_base = "Element";
		ssize_t pos = class_name.find(':');
		if(pos != std::string::npos)
		{
			class_base = class_name.substr(pos+1);
			class_name = class_name.substr(0, pos);
		}
		h <<
			"#define " << (*iter)[2] << " " << (*iter)[3] << "\n"
			"class " << class_name << ": public " << class_base << "\n"
			"{\n"
			"public:\n"
			"\t" << class_name << "();\n"
			"\tvirtual ~" << class_name << "();\n"
			<< element_classes[class_name] << "\n"
			"};\n";
		cpp <<
			"\telements.push_back(" << class_name << "());\n";
	}
	h <<
		"std::vector<Element> GetElements();\n"
		"#endif\n";
	cpp <<
		"return elements;\n"
		"}\n";
	std::ofstream file_h;
	file_h.open("src/ElementClasses.h");
	if(file_h.good())
		file_h << h.rdbuf();
	file_h.close();
	std::ofstream file_cpp;
	file_cpp.open("src/ElementClasses.cpp");
	if(file_cpp.good())
		file_cpp << cpp.rdbuf();
	file_cpp.close();
}

void generate_tools(std::list<std::string> files)
{
	std::stringstream cpp, h;
	h <<
		"// This file is automatically generated by " __FILE__ "\n"
		"#ifndef TOOLCLASSES_H\n"
		"#define TOOLCLASSES_H\n"
		"#include <vector>\n"
		"#include \"simulation/tools/SimTool.h\"\n"
		"\n";
	cpp <<
		"// This file is automatically generated by " __FILE__ "\n"
		"#include \"ToolClasses.h\"\n"
		"std::vector<SimTool*> GetTools()\n"
		"{\n"
		"\tstd::vector<SimTool*> tools;\n";
	std::list<std::vector<std::string> > directives;
	for(std::list<std::string>::const_iterator iter = files.begin(), end = files.end(); iter != end; iter++)
	{
		std::ifstream file;
		file.open(iter->c_str());
		if(!file.good())
		{
			file.open(("src/simulation/tools/" + *iter).c_str());
			if(!file.good())
			{
				std::cout << "Could not open " << *iter << std::endl;
				continue;
			}
		}
		while(!file.eof())
		{
			std::string line;
			std::getline(file, line);
			if(!line.compare(0, 17, "//#TPT-Directive "))
			{
				std::istringstream iss(line.substr(17));
				std::vector<std::string> tokens;
				std::copy(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>(), std::back_inserter<std::vector<std::string> >(tokens));
				directives.push_back(tokens);
			}
		}
	}
	std::vector<std::vector<std::string> > tool_ids;
	std::map<std::string,std::string> tool_classes;
	for(std::list<std::vector<std::string> >::const_iterator iter = directives.begin(), end = directives.end(); iter != end; iter++)
	{
		if(!(*iter)[0].compare("ToolClass"))
			tool_ids.push_back(*iter);
		else if(!(*iter)[0].compare("ToolHeader"))
		{
			tool_classes[(*iter)[1]] += flatten((*iter).begin()+2, (*iter).end()) + ";";
		}
	}
	std::sort(tool_ids.begin(), tool_ids.end(), sort_elements);
	for(std::vector<std::vector<std::string> >::const_iterator iter = tool_ids.begin(), end = tool_ids.end(); iter != end; iter++)
	{
		std::string class_name = (*iter)[1];
		h <<
			"#define " << (*iter)[2] << " " << (*iter)[3] << "\n"
			"class " << class_name << ": public SimTool\n"
			"{\n"
			"public:\n"
			"\t" << class_name << "();\n"
			"\tvirtual ~" << class_name << "();\n"
			"\tvirtual int Perform(Simulation *sim, Particle *cpart, int x, int y, float strength);\n"
			<< tool_classes[class_name] << "\n"
			"};\n";
		cpp <<
			"\ttools.push_back(new " << class_name << "());\n";
	}
	h <<
		"std::vector<SimTool*> GetTools();\n"
		"#endif\n";
	cpp <<
		"return tools;\n"
		"}\n";
	std::ofstream file_h;
	file_h.open("src/ToolClasses.h");
	if(file_h.good())
		file_h << h.rdbuf();
	file_h.close();
	std::ofstream file_cpp;
	file_cpp.open("src/ToolClasses.cpp");
	if(file_cpp.good())
		file_cpp << cpp.rdbuf();
	file_cpp.close();
}

int main(int argc,char *argv[])
{
	DIR *dir;
	struct dirent *ent;
	
	std::list<std::string> elements;
	dir = opendir("src/simulation/elements");
	while(ent = readdir(dir))
		if(ent->d_name[0] != '.')
			elements.push_back(ent->d_name);
	closedir(dir);
	generate_elements(elements);

	std::list<std::string> tools;
	dir = opendir("src/simulation/tools");
	while(ent = readdir(dir))
		if(ent->d_name[0] != '.')
			tools.push_back(ent->d_name);
	closedir(dir);
	generate_tools(tools);
	return 0;
}
